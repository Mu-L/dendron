/* eslint-disable import/no-dynamic-require, global-require */
import _ from "lodash";
import fs from "fs-extra";
import path from "path";
import * as v from "@badrap/valita";
import { ok, err } from "neverthrow";
import type { NotePropsByIdDict, DuplicateNoteBehavior } from "./types";
// import type { TreeMenu, TreeMenuNode } from "./util/treeUtil";
import { parse } from "./parse";

type Option<T> = T | undefined;

const noteLiteral = v.literal("note");
const autogeneratedLiteral = v.literal("autogenerated");
const categoryLiteral = v.literal("category");

const sidebarItemNote = v.object({
  type: noteLiteral,
  id: v.string(),
  label: v.string(),
});

// type SidebarItemNote = v.Infer<typeof sidebarItemNote>;

const sidebarItemAutogenerated = v.object({
  type: autogeneratedLiteral,
  id: v.string(),
});

type SidebarItemAutogenerated = v.Infer<typeof sidebarItemAutogenerated>;

const sidebarItemCategoryLinkNote = v.object({
  type: noteLiteral,
  id: v.string(),
});

type SidebarItemCategory = {
  type: "category";
  label: string;
  items: SidebarItem[];
};

const sidebarItemCategory: v.Type<SidebarItemCategory> = v.lazy(() =>
  v.object({
    type: categoryLiteral,
    label: v.string(),
    items: v.array(v.lazy(() => sidebarItem)),
    link: sidebarItemCategoryLinkNote,
  })
);

const sidebarItem = v.union(
  sidebarItemCategory,
  sidebarItemNote,
  sidebarItemAutogenerated
);

type SidebarItem = v.Infer<typeof sidebarItem>;

const sidebarItemProcessed = v.union(sidebarItemCategory, sidebarItemNote);

type SidebarItemProcessed = v.Infer<typeof sidebarItemProcessed>;

const sidebar = v.array(sidebarItem);
const sidebarProcessed = v.array(sidebarItemProcessed);

type Sidebar = v.Infer<typeof sidebar>;
type SidebarProcessed = v.Infer<typeof sidebarProcessed>;

const sidebars = v.record(sidebar);
const sidebarsProcessed = v.record(sidebarProcessed);

type Sidebars = v.Infer<typeof sidebars>;
type SidebarsProcessed = v.Infer<typeof sidebarsProcessed>;

type SidebarItemsGeneratorParams = {
  item: SidebarItemAutogenerated;
  notes: NotePropsByIdDict;
  duplicateNoteBehavior?: DuplicateNoteBehavior;
};
type SidebarItemsGenerator = (
  params: SidebarItemsGeneratorParams
) => SidebarItemProcessed[];

type SidebarOptions = {
  duplicateNoteBehavior?: DuplicateNoteBehavior;
  sidebarItemsGenerator?: SidebarItemsGenerator;
  notes: NotePropsByIdDict;
};

export const DefaultSidebars: Sidebars = {
  defaultSidebar: [
    {
      type: "autogenerated",
      id: ".",
    },
  ],
};

export const DisabledSidebars: Sidebars = {};

const defaultSidbarItemsGenerator: SidebarItemsGenerator = ({
  item,
  notes,
  duplicateNoteBehavior,
}) => {
  // 1. check if reference uses `id`. 2. find note based on `fname`
  const possibleNote = [
    notes[item.id] ??
      Object.values(notes).filter((note) => note.fname === item.id),
  ].flat();

  const hasDuplicates = possibleNote.length > 1;

  // check if more than a single note was found and if yes than use `duplicateNoteBehavior` to select a single note. default to the first.
  const note =
    (hasDuplicates &&
      do_(() => {
        const map = new Map(
          possibleNote.map((note) => [
            note.vault.name ?? note.vault.fsPath,
            note,
          ])
        );
        return getPriorityVaults(duplicateNoteBehavior)
          ?.filter((vaultName) => map.has(vaultName))
          .map((vaultName) => map.get(vaultName))
          .at(0);
      })) ||
    possibleNote.at(0);

  console.log("note:", note);

  return [];
};

function processSiderbar(
  sidebar: Sidebar,
  { notes, duplicateNoteBehavior, sidebarItemsGenerator }: SidebarOptions
): SidebarProcessed {
  function processAutoGeneratedItem(item: SidebarItemAutogenerated) {
    return (
      sidebarItemsGenerator?.({ item, notes, duplicateNoteBehavior }) ??
      defaultSidbarItemsGenerator({ item, notes, duplicateNoteBehavior })
    );
  }
  function processItem(item: SidebarItem): SidebarItemProcessed[] {
    if (item.type === "category") {
      return [
        {
          ...item,
          items: item.items.map(processItem).flat(),
        },
      ];
    }
    if (item.type === "autogenerated") {
      return processAutoGeneratedItem(item);
    }
    return [item];
  }

  return sidebar.map(processItem).flat();
}

export function processSidebars(
  sidebars: Sidebars,
  options: SidebarOptions
): SidebarsProcessed {
  const processedSidebars = _.mapValues(sidebars, (sidebar) =>
    processSiderbar(sidebar, options)
  );
  return processedSidebars;
}
// export function preProcessSidebars(sidebars: Sidebars) {}

async function loadSidebarsFile(
  sidebarFilePath: string | false | undefined
): Promise<unknown> {
  // false => no sidebars
  if (sidebarFilePath === false) {
    return DisabledSidebars;
  }

  // undefined => defaults to autogenerated sidebars
  if (typeof sidebarFilePath === "undefined") {
    return DefaultSidebars;
  }

  // Non-existent sidebars file: no sidebars
  if (!(await fs.pathExists(sidebarFilePath))) {
    return DisabledSidebars;
  }

  return require(path.resolve(sidebarFilePath));
}

export async function loadSidebars(
  sidebarFilePath: string | false | undefined,
  options: SidebarOptions
) {
  const sidebarsConfig = await loadSidebarsFile(sidebarFilePath);
  const sidebarsConfigResult = parse(sidebars, sidebarsConfig);
  if (sidebarsConfigResult.isOk()) {
    return ok(processSidebars(sidebarsConfigResult.value, options));
  }
  return err(sidebarsConfigResult);
}

function getPriorityVaults(
  duplicateNoteBehavior?: DuplicateNoteBehavior
): Option<string[]> {
  if (Array.isArray(duplicateNoteBehavior?.payload)) {
    return duplicateNoteBehavior?.payload;
  }
  const vaultName = duplicateNoteBehavior?.payload.vault?.name;
  if (vaultName) {
    return [vaultName];
  }
  return undefined;
}

function do_<T>(f: () => T): T {
  return f();
}
