import _ from "lodash";
import * as v from "@badrap/valita";
import { ok, err } from "neverthrow";
import type {
  NotePropsByIdDict,
  DuplicateNoteBehavior,
  DNodePointer,
} from "./types";
import type { Option } from "./utils";
import { do_ } from "./utils";
import { parse } from "./parse";

const noteLiteral = v.literal("note");
const autogeneratedLiteral = v.literal("autogenerated");
const categoryLiteral = v.literal("category");

const idSchema = v.string();
// TODO validate: .assert();

const sidebarItemNote = v.object({
  type: noteLiteral,
  id: idSchema,
  label: v.string(),
});

type SidebarItemNote = v.Infer<typeof sidebarItemNote>;

const sidebarItemAutogenerated = v.object({
  type: autogeneratedLiteral,
  id: idSchema,
});

type SidebarItemAutogenerated = v.Infer<typeof sidebarItemAutogenerated>;

const sidebarItemCategoryLinkNote = v.object({
  type: noteLiteral,
  id: idSchema,
});

const sidebarItemCategoryLink = v.union(sidebarItemCategoryLinkNote);

type SidebarItemCategoryLink = v.Infer<typeof sidebarItemCategoryLink>;

type SidebarItemCategory = {
  type: "category";
  label: string;
  items: SidebarItem[];
  link: SidebarItemCategoryLink;
};

const sidebarItemCategory: v.Type<SidebarItemCategory> = v.lazy(() =>
  v.object({
    type: categoryLiteral,
    label: v.string(),
    items: v.array(v.lazy(() => sidebarItem)),
    link: sidebarItemCategoryLink,
  })
);

const sidebarItem = v.union(
  sidebarItemCategory,
  sidebarItemNote,
  sidebarItemAutogenerated
);

// TODO rename to `SidebarItemConfig` so that `SidebarItemProcessed` can be renamed to `SidebarItem`
type SidebarItem = v.Infer<typeof sidebarItem>;

type SidebarItemCategoryProcessed = {
  type: "category";
  label: string;
  items: SidebarItemProcessed[];
  link: SidebarItemCategoryLink;
};

const sidebarItemCategoryProcessed: v.Type<SidebarItemCategoryProcessed> =
  v.lazy(() =>
    v.object({
      type: categoryLiteral,
      label: v.string(),
      items: v.array(v.lazy(() => sidebarItemProcessed)),
      link: sidebarItemCategoryLink,
    })
  );

const sidebarItemProcessed = v.union(
  sidebarItemCategoryProcessed,
  sidebarItemNote
);

export type SidebarItemProcessed = v.Infer<typeof sidebarItemProcessed>;

const sidebar = v.array(sidebarItem);
const sidebarProcessed = v.array(sidebarItemProcessed);

type Sidebar = v.Infer<typeof sidebar>;
type SidebarProcessed = v.Infer<typeof sidebarProcessed>;

const sidebars = v.record(sidebar);
const sidebarsProcessed = v.record(sidebarProcessed);

type Sidebars = v.Infer<typeof sidebars>;
export type SidebarsProcessed = v.Infer<typeof sidebarsProcessed>;

type SidebarItemsGeneratorParams = {
  item: SidebarItemAutogenerated;
  notes: NotePropsByIdDict;
  duplicateNoteBehavior?: DuplicateNoteBehavior;
};
type SidebarItemsGenerator = (
  params: SidebarItemsGeneratorParams
) => SidebarItemProcessed[];

type SidebarOptions = {
  duplicateNoteBehavior?: DuplicateNoteBehavior;
  notes: NotePropsByIdDict;
};

export const DefaultSidebars: Sidebars = {
  defaultSidebar: [
    {
      type: "autogenerated",
      id: "root",
    },
  ],
};

export const DisabledSidebars: Sidebars = {};

const defaultSidebarItemsGenerator: SidebarItemsGenerator = ({
  item,
  notes: notesById,
  duplicateNoteBehavior,
}) => {
  function findHierarchySource() {
    const possibleHierarchySources = [
      // 1. check if reference uses `id`.
      notesById[item.id] ??
        // 2. find note based on `fname`
        Object.values(notesById).filter((note) => {
          return note.fname === item.id;
        }),
    ].flat();

    const hasDuplicates = possibleHierarchySources.length > 1;

    const note =
      // if more than a single note was found than use `duplicateNoteBehavior` to select a single note.
      (hasDuplicates &&
        do_(() => {
          const map = new Map(
            possibleHierarchySources.map((note) => [
              note.vault.name ?? note.vault.fsPath,
              note,
            ])
          );
          return getPriorityVaults(duplicateNoteBehavior)
            ?.filter((vaultName) => map.has(vaultName))
            .map((vaultName) => map.get(vaultName))
            .at(0);
        })) ||
      // default to first
      possibleHierarchySources.at(0);

    return note;
  }

  function generateSidebar(noteIds: DNodePointer[]): SidebarProcessed {
    return noteIds
      .map((noteId) => {
        const note = notesById[noteId];
        const { children } = note;
        const hasChildren = children.length > 0;
        const isCategory = hasChildren;
        const isNote = !hasChildren;

        if (!note) {
          return undefined;
        }

        if (isNote) {
          return {
            type: "note",
            id: note.id,
            label: note.title,
          } as SidebarItemNote;
        }

        if (isCategory) {
          return {
            type: "category",
            label: note.title,
            items: generateSidebar(children),
            link: { type: "note", id: note.id },
          } as SidebarItemCategory;
        }

        return undefined;
      })
      .filter((maybeSidebarItem): maybeSidebarItem is SidebarItemProcessed =>
        Boolean(maybeSidebarItem)
      );
  }

  const hierarchySource = findHierarchySource();
  if (!hierarchySource) {
    return [];
  }

  const sidebar = generateSidebar(hierarchySource.children);

  return sidebar;
};

function processSiderbar(
  sidebar: Sidebar,
  { notes, duplicateNoteBehavior }: SidebarOptions
): SidebarProcessed {
  function processAutoGeneratedItem(item: SidebarItemAutogenerated) {
    return (
      // optional future feature to control sidebarItems generation
      defaultSidebarItemsGenerator({ item, notes, duplicateNoteBehavior })
    );
  }
  function processItem(item: SidebarItem): SidebarItemProcessed[] {
    if (item.type === "category") {
      return [
        {
          ...item,
          items: item.items.map(processItem).flat(),
        },
      ];
    }
    if (item.type === "autogenerated") {
      return processAutoGeneratedItem(item);
    }
    return [item];
  }

  return sidebar.map(processItem).flat();
}

function processSidebars(
  sidebars: Sidebars,
  options: SidebarOptions
): SidebarsProcessed {
  const processedSidebars = _.mapValues(sidebars, (sidebar) =>
    processSiderbar(sidebar, options)
  );
  return processedSidebars;
}

// function preProcessSidebars(sidebars: Sidebars) {}

export async function getSidebars(input: unknown, options: SidebarOptions) {
  const sidebarsConfigResult = parse(sidebars, input);
  if (sidebarsConfigResult.isOk()) {
    return ok(processSidebars(sidebarsConfigResult.value, options));
  }
  return err(sidebarsConfigResult);
}

function getPriorityVaults(
  duplicateNoteBehavior?: DuplicateNoteBehavior
): Option<string[]> {
  if (Array.isArray(duplicateNoteBehavior?.payload)) {
    return duplicateNoteBehavior?.payload;
  }
  const vaultName = duplicateNoteBehavior?.payload.vault?.name;
  if (vaultName) {
    return [vaultName];
  }
  return undefined;
}
